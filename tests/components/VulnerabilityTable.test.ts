import { describe, it, expect, vi, beforeEach } from 'vitest';
import { JSDOM } from 'jsdom';
import '@testing-library/jest-dom/vitest';

// Create a simplified test DOM structure
function setupDOM() {
  const dom = new JSDOM(`
    <!DOCTYPE html>
    <html>
      <head></head>
      <body>
        <table id="reportTable">
          <thead>
            <tr>
              <th data-sort-key="cve"><span>↕</span></th>
              <th data-sort-key="title"><span>↕</span></th>
              <th data-sort-key="cvss"><span>↕</span></th>
              <th data-sort-key="epss"><span>↕</span></th>
              <th data-sort-key="severity"><span>↕</span></th>
              <th data-sort-key="zeroday"><span>↕</span></th>
              <th data-sort-key="date"><span>↕</span></th>
            </tr>
          </thead>
          <tbody id="reportTableBody">
            <tr data-cve="cve-1" data-severity="High" data-date="2024-07-20" data-zeroday="false" data-cvss="7.5" data-epss="0.25">
              <td>CVE-2024-0001</td>
              <td>Report One</td>
              <td data-value="7.5">7.5</td>
              <td data-value="0.25">25.0%</td>
              <td>High</td>
              <td>No</td>
              <td data-value="1595203200000">Jul 20, 2024</td>
            </tr>
            <tr data-cve="cve-2" data-severity="Critical" data-date="2024-07-18" data-zeroday="true" data-cvss="9.8" data-epss="0.85">
              <td>CVE-2024-0002</td>
              <td>Report Two</td>
              <td data-value="9.8">9.8</td>
              <td data-value="0.85">85.0%</td>
              <td>Critical</td>
              <td>Yes</td>
              <td data-value="1595030400000">Jul 18, 2024</td>
            </tr>
            <tr data-cve="cve-3" data-severity="Medium" data-date="2024-07-15" data-zeroday="false" data-cvss="5.2" data-epss="0.15">
              <td>CVE-2024-0003</td>
              <td>Report Three</td>
              <td data-value="5.2">5.2</td>
              <td data-value="0.15">15.0%</td>
              <td>Medium</td>
              <td>No</td>
              <td data-value="1594771200000">Jul 15, 2024</td>
            </tr>
          </tbody>
        </table>
        <div id="activeFilters" class="hidden">
          <div id="activeFiltersList"></div>
        </div>
      </body>
    </html>
  `);

  // Make the DOM available globally
  global.document = dom.window.document;
  global.window = dom.window as any;
  
  // Mock necessary browser methods
  Object.defineProperty(window, 'history', {
    value: { pushState: vi.fn() },
    writable: true
  });
  
  const localStorage = {
    getItem: vi.fn(),
    setItem: vi.fn()
  };
  Object.defineProperty(window, 'localStorage', {
    value: localStorage,
    writable: true
  });
  
  window.URLSearchParams = vi.fn().mockImplementation(function() {
    let params = {};
    this.get = (key) => params[key];
    this.set = (key, value) => { params[key] = value; };
    this.has = (key) => params.hasOwnProperty(key);
    this.delete = (key) => { delete params[key]; };
    this.toString = () => Object.entries(params).map(([k, v]) => `${k}=${v}`).join('&');
  });
  
  window.URL = vi.fn().mockImplementation(function() {
    this.searchParams = new URLSearchParams();
  }) as any;
  
  return { document, window, localStorage };
}

// Functions that match the actual implementation
function setupTableFunctions() {
  const table = document.getElementById('reportTable');
  const tableBody = document.getElementById('reportTableBody');
  const sortableHeaders = document.querySelectorAll('th[data-sort-key]');
  const activeFiltersContainer = document.getElementById('activeFilters');
  const activeFiltersList = document.getElementById('activeFiltersList');

  // State matching the actual implementation
  const state = {
    sort: 'date',
    dir: 'desc',
    filters: {}
  };
  
  // Sort function similar to the implementation in index.astro
  function applySorting() {
    // Get rows as array for sorting
    const rows = Array.from(tableBody.querySelectorAll('tr:not([hidden])'));
    
    // Sort rows
    rows.sort((rowA, rowB) => {
      // Get cell to sort by
      const cellA = rowA.querySelector(`td[data-value]`) || rowA.cells[getColumnIndex(state.sort)];
      const cellB = rowB.querySelector(`td[data-value]`) || rowB.cells[getColumnIndex(state.sort)];
      
      // Get values
      let valueA, valueB;
      
      if (state.sort === 'zeroday') {
        valueA = rowA.getAttribute('data-zeroday') === 'true';
        valueB = rowB.getAttribute('data-zeroday') === 'true';
      } else if (cellA.hasAttribute('data-value') && cellB.hasAttribute('data-value')) {
        valueA = cellA.getAttribute('data-value');
        valueB = cellB.getAttribute('data-value');
        
        // Convert numeric values
        if (!isNaN(Number(valueA)) && !isNaN(Number(valueB))) {
          valueA = Number(valueA);
          valueB = Number(valueB);
        }
      } else {
        valueA = cellA.textContent.trim().toLowerCase();
        valueB = cellB.textContent.trim().toLowerCase();
      }
      
      // Compare
      if (valueA === valueB) return 0;
      
      const direction = state.dir === 'asc' ? 1 : -1;
      return valueA > valueB ? direction : -direction;
    });
    
    // Clear table body
    while (tableBody.firstChild) {
      tableBody.removeChild(tableBody.firstChild);
    }
    
    // Add sorted rows
    rows.forEach(row => tableBody.appendChild(row));
    
    return rows;
  }
  
  // Filter function similar to the implementation in index.astro
  function applyFiltering() {
    if (!state.filters) return 0;
    
    const rows = tableBody.querySelectorAll('tr');
    let visibleCount = 0;
    
    rows.forEach(row => {
      let visible = true;
      
      // Apply Zero-Day filter
      if (visible && state.filters.zeroDay) {
        const isZeroDay = row.getAttribute('data-zeroday') === 'true';
        if (!isZeroDay) visible = false;
      }
      
      // Apply CVSS Min filter
      if (visible && state.filters.cvssMin > 0) {
        const cvssScore = parseFloat(row.getAttribute('data-cvss') || '0');
        if (cvssScore < state.filters.cvssMin) visible = false;
      }
      
      // Apply EPSS Min filter
      if (visible && state.filters.epssMin > 0) {
        const epssScore = parseFloat(row.getAttribute('data-epss') || '0');
        if (epssScore < state.filters.epssMin) visible = false;
      }
      
      // Apply Severity filters
      if (visible && state.filters.severity && 
          (state.filters.severity.critical || 
           state.filters.severity.high || 
           state.filters.severity.medium || 
           state.filters.severity.low)) {
        
        const rowSeverity = row.getAttribute('data-severity');
        
        if (rowSeverity) {
          const matchesSeverity = 
            (rowSeverity === 'Critical' && state.filters.severity.critical) ||
            (rowSeverity === 'High' && state.filters.severity.high) ||
            (rowSeverity === 'Medium' && state.filters.severity.medium) ||
            (rowSeverity === 'Low' && state.filters.severity.low);
            
          if (!matchesSeverity) visible = false;
        }
      }
      
      // Update visibility
      row.hidden = !visible;
      if (visible) visibleCount++;
    });
    
    return visibleCount;
  }
  
  // Helper to get column index
  function getColumnIndex(key) {
    switch (key) {
      case 'cve': return 0;
      case 'title': return 1;
      case 'cvss': return 2;
      case 'epss': return 3;
      case 'severity': return 4;
      case 'zeroday': return 5;
      case 'date': return 6;
      default: return 0;
    }
  }
  
  return { state, applySorting, applyFiltering, tableBody };
}

describe('Vulnerability Table Functionality', () => {
  let testEnv;
  
  beforeEach(() => {
    setupDOM();
    testEnv = setupTableFunctions();
  });
  
  it('sorts rows by date descending by default', () => {
    testEnv.state.sort = 'date';
    testEnv.state.dir = 'desc';
    
    const sortedRows = testEnv.applySorting();
    
    // Get the dates from the sorted rows
    const dates = sortedRows.map(row => 
      Number(row.querySelector('td[data-value]').getAttribute('data-value'))
    );
    
    // Check if dates are in descending order
    expect(dates[0]).toBeGreaterThan(dates[1]);
    expect(dates[1]).toBeGreaterThan(dates[2]);
  });
  
  it('sorts rows by cvss score in descending order', () => {
    testEnv.state.sort = 'cvss';
    testEnv.state.dir = 'desc';
    
    const sortedRows = testEnv.applySorting();
    
    // Get the CVSS scores from the sorted rows
    const scores = sortedRows.map(row => 
      Number(row.cells[2].getAttribute('data-value'))
    );
    
    // Expect highest CVSS first
    expect(scores[0]).toBe(9.8);
    expect(scores[1]).toBe(7.5);
    expect(scores[2]).toBe(5.2);
  });
  
  it('filters rows by severity', () => {
    testEnv.state.filters = {
      severity: {
        critical: true,
        high: false,
        medium: false,
        low: false
      }
    };
    
    const visibleCount = testEnv.applyFiltering();
    const visibleRows = Array.from(testEnv.tableBody.querySelectorAll('tr'))
      .filter(row => !row.hidden);
    
    // Should only show Critical severity rows
    expect(visibleCount).toBe(1);
    expect(visibleRows.length).toBe(1);
    expect(visibleRows[0].getAttribute('data-severity')).toBe('Critical');
  });
  
  it('filters rows by zero-day status', () => {
    testEnv.state.filters = {
      zeroDay: true
    };
    
    const visibleCount = testEnv.applyFiltering();
    const visibleRows = Array.from(testEnv.tableBody.querySelectorAll('tr'))
      .filter(row => !row.hidden);
    
    // Should only show zero-day rows
    expect(visibleCount).toBe(1);
    expect(visibleRows.length).toBe(1);
    expect(visibleRows[0].getAttribute('data-zeroday')).toBe('true');
  });
  
  it('filters by CVSS score', () => {
    testEnv.state.filters = {
      cvssMin: 7.0
    };
    
    const visibleCount = testEnv.applyFiltering();
    const visibleRows = Array.from(testEnv.tableBody.querySelectorAll('tr'))
      .filter(row => !row.hidden);
    
    // Should only show rows with CVSS >= 7.0
    expect(visibleCount).toBe(2);
    expect(visibleRows.length).toBe(2);
    
    // Check that all visible rows have CVSS >= 7.0
    const allAboveThreshold = visibleRows.every(row => {
      const cvss = parseFloat(row.getAttribute('data-cvss') || '0');
      return cvss >= 7.0;
    });
    
    expect(allAboveThreshold).toBe(true);
  });
  
  it('combines multiple filters', () => {
    testEnv.state.filters = {
      cvssMin: 7.0,
      severity: {
        high: true,
        critical: false,
        medium: false,
        low: false
      }
    };
    
    const visibleCount = testEnv.applyFiltering();
    const visibleRows = Array.from(testEnv.tableBody.querySelectorAll('tr'))
      .filter(row => !row.hidden);
    
    // Should only show high severity rows with CVSS >= 7.0
    expect(visibleCount).toBe(1);
    expect(visibleRows.length).toBe(1);
    expect(visibleRows[0].getAttribute('data-severity')).toBe('High');
    expect(parseFloat(visibleRows[0].getAttribute('data-cvss'))).toBeGreaterThanOrEqual(7.0);
  });
});